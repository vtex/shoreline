import { Section } from '@site/src/components/Section'

<Section hasExplanation>

## Usage

```jsx
import { Table, useTableState } from '@vtex/admin-ui'

function Example() {
  /**
   * The hook returns the Table state
   */
  const state = useTableState({
    /**
     * Columns shape, read more about it on the rendering section
     */
    columns: [
      {
        id: 'productName',
        header: 'Product name',
      },
      {
        id: 'inStock',
        header: 'In Stock',
      },
      {
        id: 'price',
        header: 'Price',
      },
      {
        id: 'skus',
        header: 'SKUs',
      },
    ],
    /**
     * List of items to render
     */
    items: [
      {
        id: 1,
        productName: 'Orange',
        inStock: 380,
        skus: 0,
        price: 120,
      },
    ],
  })
  /**
   * You must use the `state` prop so that your Table comes to life
   * This is the only prop that is required
   */
  return <Table state={state} />
}
```

</Section>

<Section hasExplanation>

## State

The state hook `useTableState` contains all business logic needed for the component.

</Section>

<Section>

### useTableState

| Name       | Type                          | Description                                                                | Required | Default                       |
| ---------- | ----------------------------- | -------------------------------------------------------------------------- | -------- | ----------------------------- |
| columns    | `Column<T>[]`                 | Table column spec                                                          | âœ…       | -                             |
| view       | `DataViewState`               | Related DataView state                                                     | ðŸš«       | -                             |
| context    | `ResolverContext`             | Resolver context                                                           | ðŸš«       | -                             |
| resolvers  | `Record<string, Resolver<T>>` | Table field resolvers                                                      | ðŸš«       | Table's default resolvers     |
| items      | `T[]`                         | Table items                                                                | ðŸš«       | `[]`                          |
| length     | `number`                      | Expected items length, this will also control the number of skeleton items | ðŸš«       | `5`                           |
| sort       | `UseTableSortParams<T>`       | useTableSort hook params                                                   | ðŸš«       | -                             |
| getRowKey  | `(item: T) => string`         | Key extractor                                                              | ðŸš«       | Table's default key extractor |
| onRowClick | `(item: T) => void`           | Action to dispatch on a row click                                          | ðŸš«       | -                             |

It returns an object with the following types

```ts
interface TableState<T> {
  /**
   * Collection rendered while loading
   */
  skeletonCollection: T[]
  /**
   * Resolves the cell content
   */
  resolveCell: (args: ResolverCallee<ResolveCellArgs<T>>) => ReactNode
  /**
   * Resolvers the header content
   */
  resolveHeader: (
    args: ResolverCallee<ResolveHeaderArgs<T>>
  ) => ResolveHeaderReturn
  /**
   * Items to render
   */
  data: T[]
  /**
   * Grid columns
   */
  columns: Array<Column<T>>
  /**
   * Providers from the resolvers
   */
  Providers: (props: PropsWithChildren<unknown>) => JSX.Element
  /**
   * Current sorting state
   */
  sortState: UseSortReturn
  /**
   * Key extractor
   */
  getRowKey: (item: T) => string | unknown
  /**
   * Action to take on click a row
   */
  onRowClick?: (item: T) => void
}

/**
 * Caller of a resolver
 */
type ResolverCallee<T> = Omit<T, 'resolvers' | 'context' | 'sortState'>
```

</Section>

<Section hasExplanation>

## Rendering

The main objective of `Table` is to provide a flexible render to support any kind of data type.

| Attribute | Type                                            | Description                                                                                                                                                                                                                         | Required |
| --------- | ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |
| id        | `string`                                        | String that defines the property name that the column represents.                                                                                                                                                                   | âœ…       |
| header    | `((column: Column<T>) => ReactNode), or string` | Controls the title which appears on the table Header.<br />It can receive either a string or an element.                                                                                                                            | ðŸš«       |
| accessor  | `((item: T) => ReactNode), or string`           | Defines how to access a property                                                                                                                                                                                                    | ðŸš«       |
| resolver  | `R`                                             | [Resolvers](#resolvers) api<br />Will select the [plain resolver](#plain) by default                                                                                                                                                | ðŸš«       |
| width     | `number`                                        | Defines a fixed width for the specific column.<br />Receives either a string or number.<br />By default, the column's width is defined to fit the available space without breaking the content.                                     | ðŸš«       |
| sortable  | `(a: T, b: T) => number`                        | Defines if that column is sortable or not, passing true to this prop won't sort items by itself, the sorting will still need to be handled using the sort prop inside the StatelessTable sort prop. Check [Sorting](table/#sorting) | ðŸš«       |
| compare   | `boolean`                                       | The function provided to handle the sorting of this column of the table, if this function is provided the table items will be sorted based on this function result. Check [Sorting](table/#sorting)                                 | ðŸš«       |

</Section>

<Section hasExplanation>

## Accessor

Some properties may be nested within objects and arrays. The `accessor` properties provide an easy way to access those.

```jsx noInline live
const items = [
  {
    id: 1,
    product: {
      name: 'Orange',
      type: 'Fruit',
    },
    qty: {
      sold: 100,
      total: 320,
    },
    skus: {
      value: [0, 10, 20],
    },
    price: [120, 'usd'],
  },
]

function Example() {
  const state = useTableState({
    columns: [
      {
        id: 'product.name',
        header: 'Name',
        accessor: 'product.name',
      },
      {
        id: 'product.type',
        header: 'Type',
        accessor: 'product.type',
      },
      {
        id: 'qty',
        header: 'In Stock',
        accessor: (item) => {
          const {
            qty: { total, sold },
          } = item
          return total - sold
        },
      },
      {
        id: 'price',
        header: 'Price',
        accessor: 'price.0',
      },
      {
        id: 'skus',
        header: 'SKUs',
        accessor: 'skus.value.2',
      },
    ],
    items,
    onRowClick: (item) => alert(`Item: ${item.product.name}`),
  })

  return <Table state={state} />
}

render(<Example />)
```

</Section>

<Section hasExplanation>

## Resolvers

Resolvers are rendering functions that target a specific data type. The main usage is to render the same data types consistently along with admin applications.

</Section>

<Section hasExplanation>

### Render function

All resolvers accept a render function, that returns a component. It controls the data rendering, which may be treated by the resolver or not.

```ts
{
  type: 'resolver name',
  /**
   * You have 3 render props here:
   * { item, data, context }
   */
  render: function Render({ item, data, context }) {
    return <></>
  }
}
```

| Name    | Type                   | Description                                                         |
| ------- | ---------------------- | ------------------------------------------------------------------- |
| item    | `T`                    | the item displayed for the row                                      |
| data    | `unknown`              | extracted column data from the item, you need to cast it before use |
| context | `{ loading: boolean }` | relevant global information about the table current state           |

</Section>

<Section hasExplanation>

### Root

This is the parent of all other resolvers. It does not treat the data at all - even the loading state is completely up to you. Use it if you want complete control over what's being rendered on the cell, and don't mind the complexity that it brings.

```jsx live
function Example() {
  const state = useTableState({
    columns: [
      {
        id: 'id',
        header: 'Id',
      },
      /**
       * The great thing about the root resolver is that you can infer new columns from
       * multiple properties of the item.
       */
      {
        id: 'description',
        header: 'Description',
        resolver: {
          type: 'root',
          /**
           * { data } here would be null, because the is no such prop in the item
           */
          render: function Description({ item, context }) {
            /**
             * You should declare the render while loading
             * this is only required by the root resolver
             * the other ones, take care of this for you
             */
            if (context.status === 'loading') {
              return <Skeleton csx={{ height: 24 }} />
            }

            return (
              <Stack
                orientation="vertical"
                csx={{ justifyContent: 'center', height: 64 }}
              >
                <Text variant="highlight">
                  {item.productName} ({item.category})
                </Text>
              </Stack>
            )
          },
        },
      },
      {
        id: 'inStock',
        header: 'In Stock',
      },
    ],
    items: [
      {
        id: 1,
        productName: 'Orange',
        category: 'fruit',
        inStock: 380,
      },
      {
        id: 2,
        productName: 'Lemon',
        category: 'fruit',
        inStock: 380,
      },
    ],
    onRowClick: (item) => alert(`Item: ${item.productName}`),
  })

  return <Table state={state} />
}
```

| Name   | Type                                                  | Description              | Required |
| ------ | ----------------------------------------------------- | ------------------------ | -------- |
| type   | `root`                                                | Root resolver type       | âœ…       |
| render | ` (props: ResolverRenderProps<null, T>) => ReactNode` | Resolver render function | âœ…       |

</Section>

<Section hasExplanation>

### Plain

The plain resolver is the default for all columns. It means that if you don't select a resolver, this is what you're rendering. It should be mainly used to render raw data like strings or numbers that don't need treatment.

```jsx noInline live
const items = [
  {
    id: 1,
    productName: 'Orange',
    inStock: 380,
    skus: 0,
    price: 120,
  },
  {
    id: 2,
    productName: 'Lemon',
    inStock: 380,
    skus: 26,
    price: 120,
  },
  {
    id: 3,
    productName: 'Tomato',
    inStock: 380,
    skus: 26,
    price: 120,
  },
]

function Example() {
  const state = useTableState({
    columns: [
      {
        id: 'productName',
        header: 'Product name',
      },
      {
        id: 'inStock',
        header: 'In Stock',
      },
      {
        id: 'price',
        header: 'Price',
      },
      {
        id: 'skus',
        header: 'SKUs',
        resolver: {
          type: 'plain',
          /**
           * this is how to use the render function
           */
          render: function Render({ data }) {
            return (
              <Text tone={Number(data) > 0 ? 'info' : 'critical'}>{data}</Text>
            )
          },
        },
      },
    ],
    items,
    onRowClick: (item) => alert(`Item: ${item.productName}`),
  })

  return <Table state={state} />
}

render(<Example />)
```

| Name   | Type                                                      | Description              | Required |
| ------ | --------------------------------------------------------- | ------------------------ | -------- |
| type   | `plain`                                                   | Plain resolver type      | âœ…       |
| render | `(props: ResolverRenderProps<ReactNode, T>) => ReactNode` | Resolver render function | ðŸš«       |

</Section>

<Section hasExplanation>

### Text

The text resolver should be mainly used to render a text and an optional description just below it. It must be used for cells belonging to a `name` column.

```jsx noInline live
const items = [
  {
    id: 1,
    productName: 'Orange',
    description: 'Fruit',
    inStock: 380,
    skus: 0,
    price: 120,
  },
  {
    id: 2,
    productName: 'Lemon',
    description: 'Fruit',
    inStock: 380,
    skus: 26,
    price: 120,
  },
  {
    id: 3,
    productName: 'Tomato',
    description: 'Fruit',
    inStock: 380,
    skus: 26,
    price: 120,
  },
]

function Example() {
  const state = useTableState({
    columns: [
      {
        id: 'productName',
        header: 'Name',
        resolver: {
          type: 'text',
          columnType: 'name',
          mapText: (item) => item.productName,
          mapDescription: (item) => item.description,
        },
      },
      {
        id: 'inStock',
        header: 'In Stock',
      },
      {
        id: 'price',
        header: 'Price',
        resolver: {
          type: 'text',
          columnType: 'text',
          mapText: (item) => item.price,
          mapDescription: () => 'Recently updated',
        },
      },
      {
        id: 'skus',
        header: 'SKUs',
        resolver: {
          type: 'plain',
          /**
           * this is how to use the render function
           */
          render: function Render({ data }) {
            return (
              <Text tone={Number(data) > 0 ? 'info' : 'critical'}>{data}</Text>
            )
          },
        },
      },
    ],
    items,
    onRowClick: (item) => alert(`Item: ${item.productName}`),
  })

  return <Table state={state} />
}

render(<Example />)
```

| Name           | Type                                                      | Description                                                   | Required | Default |
| -------------- | --------------------------------------------------------- | ------------------------------------------------------------- | -------- | ------- |
| type           | `text`                                                    | Text resolver type                                            | âœ…       | -       |
| columnType     | `name or text`                                            | Column text type                                              | ðŸš«       | `text`  |
| mapText        | `(item: T) => ReactNode`                                  | The map function which returns the text to be rendered        | âœ…       | -       |
| mapDescription | `(item: T) => ReactNode`                                  | The map Function which returns the description to be rendered | ðŸš«       | -       |
| render         | `(props: ResolverRenderProps<ReactNode, T>) => ReactNode` | Resolver render function                                      | ðŸš«       | -       |

</Section>

<Section hasExplanation>

### Menu

The menu resolver should be used when you want to easily render a Menu component and a set of actions.

```jsx noInline live
const defaultItems = [
  {
    id: 1,
    productName: 'Orange',
    description: 'Fruit',
    inStock: 380,
    skus: 0,
    price: 120,
  },
  {
    id: 2,
    productName: 'Lemon',
    description: 'Fruit',
    inStock: 380,
    skus: 26,
    price: 120,
  },
  {
    id: 3,
    productName: 'Tomato',
    description: 'Fruit',
    inStock: 380,
    skus: 26,
    price: 120,
  },
]

function Example() {
  const [items, setItems] = useState(defaultItems)

  const state = useTableState({
    columns: [
      {
        id: 'productName',
        header: 'Name',
        resolver: {
          type: 'text',
          columnType: 'name',
          mapText: (item) => item.productName,
          mapDescription: (item) => item.description,
        },
      },
      {
        id: 'inStock',
        header: 'In Stock',
      },
      {
        id: 'price',
        header: 'Price',
        resolver: {
          type: 'text',
          columnType: 'text',
          mapText: (item) => item.price,
          mapDescription: () => 'Recently updated',
        },
      },
      {
        id: 'skus',
        header: 'SKUs',
        resolver: {
          type: 'plain',
          /**
           * this is how to use the render function
           */
          render: function Render({ data }) {
            return (
              <Text tone={Number(data) > 0 ? 'info' : 'critical'}>{data}</Text>
            )
          },
        },
      },
      {
        id: 'menu',
        resolver: {
          type: 'menu',
          actions: [
            {
              label: 'Edit',
              icon: <IconPencil />,
              onClick: (item) => {
                console.log(item)
              },
            },
            {
              label: 'Delete',
              icon: <IconTrash />,
              onClick: (item) => {
                setItems(items.filter((i) => i.id !== item.id))
              },
            },
          ],
        },
      },
    ],
    items,
    onRowClick: (item) => alert(`Item: ${item.productName}`),
  })

  return <Table state={state} />
}

render(<Example />)
```

| Name    | Type                                                        | Description                                  | Required | Default |
| ------- | ----------------------------------------------------------- | -------------------------------------------- | -------- | ------- |
| type    | `menu`                                                      | Menu resolver type                           | âœ…       | -       |
| actions | `MenuAction[]`                                              | A set of actions to be rendered as MenuItems | âœ…       | -       |
| render  | `(props: ResolverRenderProps<JSX.Element, T>) => ReactNode` | Resolver render function                     | ðŸš«       | -       |

**MenuAction**

| Name     | Type                | Description                             | Required | Default |
| -------- | ------------------- | --------------------------------------- | -------- | ------- |
| label    | `string`            | MenuItem label                          | âœ…       | -       |
| onClick  | `(item: T) => void` | MenuItem onClick handler                | âœ…       | -       |
| icon     | `ReactNode`         | MenuItem icon                           | ðŸš«       | -       |
| disabled | `boolean`           | Whether the MenuItem is disabled or not | ðŸš«       | `false` |
| critical | `boolean`           | Whether the MenuItem is critical or not | ðŸš«       | `false` |

</Section>

<Section>

### Currency

```jsx live
function Example() {
  const currencies = [
    {
      id: 1,
      brl: 120,
      usd: 24,
      cny: 100,
    },
  ]

  const state = useTableState({
    columns: [
      {
        id: 'brl',
        header: 'PreÃ§o',
        resolver: {
          type: 'currency',
          locale: 'pt-BR',
          currency: 'BRL',
        },
      },
      {
        id: 'usd',
        header: 'Price',
        resolver: {
          type: 'currency',
          locale: 'en-US',
          currency: 'USD',
        },
      },
      {
        id: 'cny',
        header: 'ä»·æ ¼',
        resolver: {
          type: 'currency',
          locale: 'zh-CN',
          currency: 'CNY',
        },
      },
    ],
    items: currencies,
    onRowClick: (item) => alert(`Item: ${item.id}`),
  })

  return <Table state={state} />
}
```

| Name     | Type                                                   | Description              | Required |
| -------- | ------------------------------------------------------ | ------------------------ | -------- |
| type     | `currency`                                             | Currency resolver type   | âœ…       |
| locale   | `string`                                               | Currency locale          | âœ…       |
| currency | `string`                                               | Currency type            | âœ…       |
| render   | `(props: ResolverRenderProps<string, T>) => ReactNode` | Resolver render function | ðŸš«       |

</Section>

<Section>

### Date

```jsx live
function Example() {
  const dates = [
    {
      id: 1,
      pt: '5/7/2020, 13:04',
      ar: '5/7/2020, 13:04',
      en: '5/7/2020, 13:04',
      cn: '5/7/2020, 13:04',
    },
  ]

  const state = useTableState({
    columns: [
      {
        id: 'pt',
        header: 'Data',
        resolver: {
          type: 'date',
          locale: 'pt-BR',
          options: {
            day: 'numeric',
            month: 'long',
            year: 'numeric',
          },
        },
      },
      {
        id: 'ar',
        header: 'ØªØ§Ø±ÙŠØ®',
        resolver: {
          type: 'date',
          locale: 'ar-AE',
          options: {
            day: 'numeric',
            month: 'long',
            year: 'numeric',
          },
        },
      },
      {
        id: 'en',
        header: 'Date',
        resolver: {
          type: 'date',
          locale: 'en-US',
          options: {
            day: 'numeric',
            month: 'long',
            year: 'numeric',
          },
        },
      },
      {
        id: 'cn',
        header: 'æ—¥æœŸ',
        resolver: {
          type: 'date',
          locale: 'zh-CN',
          options: {
            day: 'numeric',
            month: 'long',
            year: 'numeric',
          },
        },
      },
    ],
    items: dates,
    onRowClick: (item) => alert(`Item: ${item.id}`),
  })

  return <Table state={state} />
}
```

| Name    | Type                                                   | Description              | Required |
| ------- | ------------------------------------------------------ | ------------------------ | -------- |
| type    | `date`                                                 | Date resolver type       | âœ…       |
| locale  | `string`                                               | Date locale              | âœ…       |
| options | `Intl.DateTimeFormatOptions`                           | Date options             | ðŸš«       |
| render  | `(props: ResolverRenderProps<string, T>) => ReactNode` | Resolver render function | ðŸš«       |

</Section>

<Section>

### Image

```jsx live
function Example() {
  const fruits = [
    {
      id: 1,
      image:
        'https://images.unsplash.com/photo-1587735243615-c03f25aaff15?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1600&q=80',
      productName: 'Orange',
      stock: 26900,
      price: 120,
    },
    {
      id: 2,
      image:
        'https://images.unsplash.com/flagged/photo-1587302164675-820fe61bbd55?ixlib=rb-1.2.1&auto=format&fit=crop&w=1600&q=80',
      productName: 'Lemon',
      stock: 12905,
      price: 120,
    },
    {
      id: 3,
      image:
        'https://images.unsplash.com/photo-1587486938113-d6d38d424efa?ixlib=rb-1.2.1&auto=format&fit=crop&w=1600&q=80',
      productName: 'Tomato',
      stock: 199001,
      price: 120,
    },
  ]

  const state = useTableState({
    columns: [
      {
        id: 'image',
        header: 'Image',
        resolver: {
          type: 'image',
        },
      },
      {
        id: 'productName',
        header: 'Name',
      },
      {
        id: 'stock',
        header: 'Stock',
      },
      {
        id: 'price',
        header: 'Stock',
        resolver: {
          type: 'currency',
          locale: 'en-US',
          currency: 'USD',
        },
      },
    ],
    items: fruits,
    onRowClick: (item) => alert(`Item: ${item.productName}`),
  })

  return <Table state={state} />
}
```

```jsx live
function Example() {
  const fruits = [
    {
      id: 1,
      name: 'Color 1',
      image:
        'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRR_gD9Fm-5bttYHoJ-wxD2W8kK2boZsQItYw&usqp=CAU',
      price: 100,
    },
    {
      id: 2,
      name: 'Color 2',
      image:
        'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRsvxLXJ3jW2hQox375iMAcaScYMpUmXk1dFw&usqp=CAU',
      price: 30,
    },
    {
      id: 3,
      name: 'Color 3',
      image:
        'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR0FyiZM7bDPsDEMtg0Zs2HXNwe2xbVh55IZA&usqp=CAU',
      price: 10,
    },
  ]

  const state = useTableState({
    columns: [
      {
        id: 'image',
        header: 'Image',
        resolver: {
          type: 'image',
        },
      },
      {
        id: 'name',
        header: 'Name',
        resolver: {
          type: 'text',
          isNameCell: true,
          mapText: (item) => item.name,
        },
      },
      {
        id: 'price',
        header: 'Price',
      },
    ],
    items: fruits,
    onRowClick: (item) => alert(`Item: ${item.name}`),
  })

  return <Table state={state} />
}
```

| Name   | Type                                                        | Description              | Required |
| ------ | ----------------------------------------------------------- | ------------------------ | -------- |
| type   | `image`                                                     | Image resolver type      | âœ…       |
| alt    | `string`                                                    | HTML img alt             | ðŸš«       |
| render | `(props: ResolverRenderProps<JSX.Element, T>) => ReactNode` | Resolver render function | ðŸš«       |

</Section>

<Section hasExplanation>

### Selection

The selection resolver should be used when it is necessary to have rows selectable and to have control of which rows are selected.

```jsx noInline live
function Example() {
  const grid = useTableState({
    columns: [
      {
        id: 'id',
        resolver: {
          type: 'selection',
          mapId: (item) => item.id,
        },
      },
      {
        id: 'name',
        header: 'Name',
        resolver: {
          type: 'text',
          columnType: 'name',
          mapText: (item) => item.name,
        },
      },
      {
        id: 'lastSale',
        header: 'Last Sale',
      },
      {
        id: 'price',
        header: 'Price',
        resolver: {
          type: 'currency',
          locale: 'en-US',
          currency: 'USD',
        },
      },
    ],
    length: 3,
    items: React.useMemo(
      () =>
        Array(3)
          .fill()
          .map((_, id) => {
            return {
              id: `${id}`,
              name: faker.commerce.productName(),
              lastSale: faker.date.past().toDateString(),
              price: faker.commerce.price(),
            }
          }),
      []
    ),
    onRowClick: (item) => alert(`Item: ${item.name}`),
  })

  const selection = useSelectionTreeState({
    items: grid.data,
    mapId: (item) => item.id,
  })

  return (
    <SelectionTree state={selection}>
      <Table state={grid} />
    </SelectionTree>
  )
}

render(<Example />)
```

| Name   | Type                                                      | Description              | Required                                                         |
| ------ | --------------------------------------------------------- | ------------------------ | ---------------------------------------------------------------- | --- |
| type   | `selection`                                               | Selection resolver type  | âœ…                                                               |
| mapId  | `mapId: (item: T) => string                               | number`                  | The map function which returns the id to be used by the checkbox | ðŸš«  |
| render | `(props: ResolverRenderProps<ReactNode, T>) => ReactNode` | Resolver render function | ðŸš«                                                               |

</Section>

<Section hasExplanation>

## Sorting

To use the base sorting configuration, that matches the majority of use cases, you just need to pass the `compare` function to the columns that you want to sort by. Two params are accepted, representing two items - you must return a boolean that proves their equality.

```ts
type Compare = (a: T, b: T) => boolean
```

</Section>

<Section hasExplanation>

### Configuration

The following example allows ordering by `name`, `lastSale` and `price`. By using the `sort` property within `useTableState` you can configure the sorting to match specific use cases.

```jsx noInline live
const items = Array(3)
  .fill()
  .map((_, id) => {
    return {
      id: `${id}`,
      name: faker.commerce.productName(),
      lastSale: faker.date.past().toDateString(),
      price: faker.commerce.price(),
    }
  })

function CompareExample() {
  const state = useTableState({
    columns: [
      {
        id: 'name',
        header: 'Product Name',
        compare: (a, b) => b.name.localeCompare(a.name),
      },
      {
        id: 'lastSale',
        header: 'Last Sale',
        compare: (a, b) => {
          const aLastSale = new Date(a.lastSale).valueOf()
          const bLastSale = new Date(b.lastSale).valueOf()

          return bLastSale - aLastSale
        },
      },
      {
        id: 'price',
        header: 'Price',
        resolver: {
          type: 'currency',
          locale: 'en-US',
          currency: 'USD',
        },
        compare: (a, b) => parseInt(b.price, 10) - parseInt(a.price, 10),
      },
    ],
    items,
    sort: {
      initialValue: { order: 'ASC' },
    },
    onRowClick: (item) => alert(`Item: ${item.name}`),
  })

  return <Table state={state} />
}

render(<CompareExample />)
```

</Section>

<Section>

#### initialValue

- Defines the table's initial sorting value. `{ order?: 'ASC' | 'DESC', by?: string }`

- The `order` prop is related to the sorting order and `by` indicates which column is being sorted, this value should be the id of the column.

</Section>

<Section>

#### directions

- Defines the sorting order of the table.
- It accepts an array with `ASC` and `DESC` as possible values.
  You can pass an array with one or two sorting directions. If you pass an array with only one sorting direction the table will only sort in one direction.

</Section>

<Section>

#### reducer

- Receives the reducer that will be used inside of the `useReducer` that handles the sorting state, it is not required and if not provided the default reducer function will be used.

- The reducer function is called with the current sort state `{ order?: SortOrder, by?: string }` and the sorting action `{ type: SortOrder | 'RESET', columnId?: string }`.

</Section>

<Section>

#### callback

- Receives a function that will be fired when the user clicks the table header cell of a column.

- This function is called with an object containing the current sort state, the dispatch of the current `useReducer` that handles the sorting state, the column id of the column that was clicked, and the current sort directions being used.

</Section>
